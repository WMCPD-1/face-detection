<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face and Hand Detection Web App</title>
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .abs { position: absolute; }

        a { color: white; text-decoration: none; }
        a:hover { color: lightblue; }

        body {
            bottom: 0;
            font-family: 'Titillium Web', sans-serif;
            color: white;
            left: 0;
            margin: 0;
            position: absolute;
            right: 0;
            top: 0;
            transform-origin: 0px 0px;
            overflow: hidden;
        }

        .container {
            position: absolute;
            background-color: #596e73;
            width: 100%;
            max-height: 100%;
        }

        .input_video {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        .input_video.selfie { transform: scale(-1, 1); }

        .canvas-container {
            display: flex;
            height: 100%;
            width: 100%;
            justify-content: center;
            align-items: center;
        }

        .output_canvas {
            max-width: 100%;
            display: block;
            position: relative;
            left: 0;
            top: 0;
        }

        .logo {
            bottom: 10px;
            right: 20px;
        }
        .logo .title { color: white; font-size: 28px; }
        .logo .subtitle { position: relative; color: white; font-size: 10px; left: -30px; top: 20px; }

        .control-panel { position: absolute; left: 10px; top: 10px; }

        .loading {
            display: flex;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            align-items: center;
            backface-visibility: hidden;
            justify-content: center;
            opacity: 1;
            transition: opacity 1s;
        }
        .loading .message { font-size: x-large; }
        .loading .spinner {
            position: absolute;
            width: 120px;
            height: 120px;
            animation: spin 1s linear infinite;
            border: 32px solid #bebebe;
            border-top: 32px solid #3498db;
            border-radius: 50%;
        }

        .loaded .loading { opacity: 0; }

        .shoutout {
            left: 0;
            right: 0;
            bottom: 40px;
            text-align: center;
            font-size: 24px;
            position: absolute;
        }
    </style>
    <!-- Load required MediaPipe scripts from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video class="input_video"></video>
        <div class="canvas-container">
            <canvas class="output_canvas" width="1280px" height="720px"></canvas>
        </div>
        <div class="loading">
            <div class="spinner"></div>
            <div class="message">Loading</div>
        </div>
        <a class="abs logo" href="https://mediapipe.dev" target="_blank">
            <div style="display: flex; align-items: center; bottom: 0; right: 10px;">
                <span class="title">MediaPipe Holistic (Face & Hands)</span>
            </div>
        </a>
        <div class="shoutout">
            <div>
                <a href="https://developers.google.com/mediapipe/solutions/vision/holistic_landmarker">More info on MediaPipe Holistic</a>
            </div>
        </div>
    </div>
    <div class="control-panel"></div>

    <script>
        // Basic device support check (optional, but good for compatibility)
        function testSupport(supportedDevices) {
            // Simplified check; you can expand if needed
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('This demo requires a browser with getUserMedia support.');
            }
        }
        testSupport([{client: 'Chrome'}]);

        const controls = window;
        const mpHolistic = window;
        const drawingUtils = window;
        const cameraUtils = window;

        const config = {
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic@${mpHolistic.VERSION}/${file}`
        };

        const videoElement = document.querySelector('.input_video');
        const canvasElement = document.querySelector('.output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const controlsElement = document.querySelector('.control-panel');

        const fpsControl = new controls.FPS();

        const spinner = document.querySelector('.loading');
        spinner.ontransitionend = () => { spinner.style.display = 'none'; };

        let activeEffect = 'background'; // Can be 'mask', 'background', or 'none'

        function removeElements(landmarks, elements) {
            for (const element of elements) {
                delete landmarks[element];
            }
        }

        function removeLandmarks(results) {
            if (results.poseLandmarks) {
                removeElements(results.poseLandmarks, [0,1,2,3,4,5,6,7,8,9,10,15,16,17,18,19,20,21,22]);
            }
        }

        function connect(ctx, connectors) {
            const canvas = ctx.canvas;
            for (const connector of connectors) {
                const from = connector[0];
                const to = connector[1];
                if (from && to) {
                    if (from.visibility && to.visibility && (from.visibility < 0.1 || to.visibility < 0.1)) {
                        continue;
                    }
                    ctx.beginPath();
                    ctx.moveTo(from.x * canvas.width, from.y * canvas.height);
                    ctx.lineTo(to.x * canvas.width, to.y * canvas.height);
                    ctx.stroke();
                }
            }
        }

        function onResults(results) {
            document.body.classList.add('loaded');
            removeLandmarks(results);
            fpsControl.tick();

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.segmentationMask) {
                canvasCtx.drawImage(results.segmentationMask, 0, 0, canvasElement.width, canvasElement.height);

                if (activeEffect === 'mask' || activeEffect === 'both') {
                    canvasCtx.globalCompositeOperation = 'source-in';
                    canvasCtx.fillStyle = '#00FF007F';
                    canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                } else {
                    canvasCtx.globalCompositeOperation = 'source-out';
                    canvasCtx.fillStyle = '#0000FF7F';
                    canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                }

                canvasCtx.globalCompositeOperation = 'destination-atop';
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.globalCompositeOperation = 'source-over';
            } else {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            }

            // Draw connections for arms to hands
            canvasCtx.lineWidth = 5;
            if (results.poseLandmarks) {
                if (results.rightHandLandmarks) {
                    canvasCtx.strokeStyle = 'white';
                    connect(canvasCtx, [[results.poseLandmarks[mpHolistic.POSE_LANDMARKS.RIGHT_ELBOW], results.rightHandLandmarks[0]]]);
                }
                if (results.leftHandLandmarks) {
                    canvasCtx.strokeStyle = 'white';
                    connect(canvasCtx, [[results.poseLandmarks[mpHolistic.POSE_LANDMARKS.LEFT_ELBOW], results.leftHandLandmarks[0]]]);
                }
            }

            // Draw pose
            drawingUtils.drawConnectors(canvasCtx, results.poseLandmarks, mpHolistic.POSE_CONNECTIONS, {color: 'white'});
            drawingUtils.drawLandmarks(
                canvasCtx,
                Object.values(mpHolistic.POSE_LANDMARKS_LEFT).map(index => results.poseLandmarks[index]),
                {visibilityMin: 0.65, color: 'white', fillColor: 'rgb(255,138,0)'}
            );
            drawingUtils.drawLandmarks(
                canvasCtx,
                Object.values(mpHolistic.POSE_LANDMARKS_RIGHT).map(index => results.poseLandmarks[index]),
                {visibilityMin: 0.65, color: 'white', fillColor: 'rgb(0,217,231)'}
            );

            // Draw hands
            drawingUtils.drawConnectors(canvasCtx, results.rightHandLandmarks, mpHolistic.HAND_CONNECTIONS, {color: 'white'});
            drawingUtils.drawLandmarks(canvasCtx, results.rightHandLandmarks, {
                color: 'white',
                fillColor: 'rgb(0,217,231)',
                lineWidth: 2,
                radius: (data) => drawingUtils.lerp(data.from.z, -0.15, 0.1, 10, 1)
            });
            drawingUtils.drawConnectors(canvasCtx, results.leftHandLandmarks, mpHolistic.HAND_CONNECTIONS, {color: 'white'});
            drawingUtils.drawLandmarks(canvasCtx, results.leftHandLandmarks, {
                color: 'white',
                fillColor: 'rgb(255,138,0)',
                lineWidth: 2,
                radius: (data) => drawingUtils.lerp(data.from.z, -0.15, 0.1, 10, 1)
            });

            // Draw face
            drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
            drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_RIGHT_EYE, {color: 'rgb(0,217,231)'});
            drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_RIGHT_EYEBROW, {color: 'rgb(0,217,231)'});
            drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_LEFT_EYE, {color: 'rgb(255,138,0)'});
            drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_LEFT_EYEBROW, {color: 'rgb(255,138,0)'});
            drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_FACE_OVAL, {color: '#E0E0E0', lineWidth: 5});
            drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_LIPS, {color: '#E0E0E0', lineWidth: 5});

            canvasCtx.restore();
        }

        const holistic = new mpHolistic.Holistic(config);
        holistic.onResults(onResults);

        // Control panel for options
        new controls.ControlPanel(controlsElement, {
            selfieMode: true,
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
            effect: 'background',
        })
        .add([
            new controls.StaticText({title: 'MediaPipe Holistic'}),
            fpsControl,
            new controls.Toggle({title: 'Selfie Mode', field: 'selfieMode'}),
            new controls.SourcePicker({
                onSourceChanged: (name, type) => {
                    // Handle source change if needed
                },
                onFrame: async (input, size) => {
                    const aspect = size.height / size.width;
                    let width, height;
                    if (window.innerWidth > window.innerHeight) {
                        height = window.innerHeight;
                        width = height / aspect;
                    } else {
                        width = window.innerWidth;
                        height = width * aspect;
                    }
                    canvasElement.width = width;
                    canvasElement.height = height;
                    await holistic.send({image: input});
                },
            }),
            new controls.Slider({
                title: 'Model Complexity',
                field: 'modelComplexity',
                discrete: ['Lite', 'Full', 'Heavy'],
            }),
            new controls.Toggle({title: 'Smooth Landmarks', field: 'smoothLandmarks'}),
            new controls.Toggle({title: 'Enable Segmentation', field: 'enableSegmentation'}),
            new controls.Toggle({title: 'Smooth Segmentation', field: 'smoothSegmentation'}),
            new controls.Slider({
                title: 'Min Detection Confidence',
                field: 'minDetectionConfidence',
                range: [0, 1],
                step: 0.01
            }),
            new controls.Slider({
                title: 'Min Tracking Confidence',
                field: 'minTrackingConfidence',
                range: [0, 1],
                step: 0.01
            }),
            new controls.Slider({
                title: 'Effect',
                field: 'effect',
                discrete: {'background': 'Background', 'mask': 'Foreground', 'none': 'None'},
            }),
        ])
        .on(x => {
            const options = x;
            videoElement.classList.toggle('selfie', options.selfieMode);
            activeEffect = x['effect'];
            holistic.setOptions(options);
        });

        // Start camera
        const camera = new cameraUtils.Camera(videoElement, {
            onFrame: async () => {
                await holistic.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        camera.start();
    </script>
</body>
</html>
